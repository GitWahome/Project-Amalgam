{"id": 2, "title": "Study guide comparison", "date_posted": "2020-02-28 03:20:50.168860", "description": "<p>Testing the effectiveness of study guides when reading materials</p>", "analytics": "{}", "user_id": 1, "base_resources": {"7": {"id": 7, "title": "Study guide SAM", "date_posted": "2020-02-28 03:21:33.063821", "notebook_id": 2, "relevance": 0.0, "content": "<p>Study guide The key feature of adaptive networks is that state stored on nodes or edges can modify network structure. For example, \u25cf we might remove an edge between two nodes when states representing their political beliefs become too polarized, to model the breaking of a social relationship, or \u25cf an infected node in an epidemic model might (temporarily) lose some of its links in a social network since we tend to avoid contact with other people when we are sick so as not to spread infection. There are two models described in the Sayama reading. \u25cf Adaptive epidemic model \u2014 Edges are removed from infected nodes to susceptible nodes to avoid the spreading of a disease. \u25cf Adaptive diffusion model \u2014 Node states are changed to become closer to neighbors, and edge weights are changed to become stronger or weaker depending on whether neighbors are similar or dissimilar, respectively. We use a modified version of the adaptive diffusion model, along with everything you learned about implementing network models in the past two weeks to simulate social dynamics and splits in social groups. The majority of today\u2019s preparation for class is in the pre\u00adclass work, so make sure you work through all the questions there. Vector field plots Watch the video on what vector field plots are if you have not used them before. The purpose of a vector field plot is to show how a 2\u00addimensional state space can change for any initial conditions. It is also possible to plot 3\u00addimensional vector fields, but we will use 2\u00addimensional ones exclusively in this course. Figure 1. Example of a vector field plot. Each arrow points in the direction in which the state (x,y) will change with respect to time. Each curve (called a path or a trace) in the vector field plot shows an example of how the state can change with time in this vector field. Note that a vector on a path is always tangent to the path at that point. This is because the path flows according to the directions of the vectors. (Image credit) A vector field is called a field because there is a vector for every point in the plane. The vectors in Figure 1 might look like the are only at discrete coordinates on a grid, but there as actually a vector defined at every point in the whole continuous space. We have to place vectors on a grid for visualization purposes. Plotting a vector field in Python We use two new functions to create and plot vector fields in Python. The new functions are meshgrid() and quiver(). We start by plotting a really simple vector field on a small grid. Each vector in the field is [x + y, x\u2212 y] where (x, y) is a coordinate in the figure. The grid runs from \u20132 to 2 for both x and y. This code creates the arrays containing the discrete values for x and y at which we will plot the vectors. import numpy as np import matplotlib.pyplot as plt x = y = np.array([\u00ad2, \u00ad1, 0, 1, 2]) Now we use the meshgrid() function in NumPy to create a grid of x and y coordinates. x_grid, y_grid = np.meshgrid(x, y) These two variables each contain a 5x5 grid of coordinates, matching x and y. x_grid = [[\u00ad2 \u00ad1 0 1 2] [\u00ad2 \u00ad1 0 1 2] [\u00ad2 \u00ad1 0 1 2] [\u00ad2 \u00ad1 0 1 2] [\u00ad2 \u00ad1 0 1 2]] y_grid = [[\u00ad2 \u00ad2 \u00ad2 \u00ad2 \u00ad2] [\u00ad1 \u00ad1 \u00ad1 \u00ad1 \u00ad1] [ 0 0 0 0 0] [ 1 1 1 1 1] [ 2 2 2 2 2]] This is useful because we can get the (x, y) values by indexing into these two arrays. Now, if we want to compute a function f(x, y) at every coordinate, we can just use these grid variables rather than the original x and y variables. We compute the vector [x + y, x\u2212 y] at every coordinate in the grid: vector_x = x_grid + y_grid vector_y = x_grid \u00ad y_grid Now we have everything we need to plot the vector field using the quiver() function in Matplotlib. (The function is called quiver because a quiver is a container for arrows.) plt.figure(figsize=(6, 6)) plt.quiver(x_grid, y_grid, vector_x, vector_y) plt.xlim(\u00ad2.5, 2.5) plt.ylim(\u00ad2.5, 2.5) plt.show() Figure 2. Output from the quiver() plot of the vector field [x + y, x\u2212 y]. Note that the lengths of the arrows are scaled automatically to fit into the plot. You can change the scaling of arrow lengths using the scale and scale_units arguments of the quiver() function. Summary so far\u2014 1. Create arrays for the x and y coordinates at which you want to plot arrows. 2. Use x_grid, y_grid = np.meshgrid(x, y) to set up the coordinate grid. 3. Compute the x and y components of the vectors in the field using the x_grid and y_grid variables. 4. Plot the grid and vector field variables using the quiver() function. Another vector field plot example We repeat the steps above for the vector field [y, \u2013 sin x] in the range x \u2208 [\u20132\u03c0, 2\u03c0] and y \u2208 [\u2013\u03c0, \u03c0]. Figure 3. Output from the quiver() plot of the vector field [y, \u2013 sin x]. Here is the code: import numpy as np import matplotlib.pyplot as plt # Create grid coordinates x = np.linspace(\u00ad2 * np.pi, 2 * np.pi, 20) y = np.linspace(\u00adnp.pi, np.pi, 10) x_grid, y_grid = np.meshgrid(x, y) # Compute vector field vector_x = y_grid vector_y = \u00adnp.sin(x_grid) # Plot vector field plt.figure(figsize=(8, 4)) plt.quiver(x_grid, y_grid, vector_x, vector_y) plt.show()</p>", "analytics": "{'Support Resource 4': {'Jaccard Similarity': 0.01486988847583643, 'Word Mover': 1000, 'Text Distance': 0.0006973500697350365, 'Cosine Similarity': 0.18}}", "is_pdf": false, "pdf_url": "NONE"}}, "support_resources": {"3": {"id": 3, "title": "SAM 1-Adaptive networks", "date_posted": "2020-02-28 03:21:42.451522", "notebook_id": 2, "relevance": 0.0, "content": "/static/notebook_files/support/8ff145b9f013f4d8.pdf", "analytics": "{'Study guide SAM': {'0': {'Cosine Similarity': 0.6, 'Word Mover': 1000, 'Text Distance': 0.06488549618320616, 'Jaccard Similarity': 0.1689497716894977}, '1': {'Cosine Similarity': 0.57, 'Word Mover': 1000, 'Text Distance': 0.06485355648535562, 'Jaccard Similarity': 0.18632075471698112}, '2': {'Cosine Similarity': 0.64, 'Word Mover': 1000, 'Text Distance': 0.07740585774058573, 'Jaccard Similarity': 0.1791767554479419}, '3': {'Cosine Similarity': 0.61, 'Word Mover': 1000, 'Text Distance': 0.0594490091831803, 'Jaccard Similarity': 0.1377245508982036}, '4': {'Cosine Similarity': 0.6, 'Word Mover': 1000, 'Text Distance': 0.05595408895265419, 'Jaccard Similarity': 0.172}, '5': {'Cosine Similarity': 0.28, 'Word Mover': 1000, 'Text Distance': 0.04463040446304045, 'Jaccard Similarity': 0.06997742663656885}}}", "is_pdf": true, "pdf_url": "NONE"}, "4": {"id": 4, "title": "Adaptive networks 2", "date_posted": "2020-02-28 03:26:24.088708", "notebook_id": 2, "relevance": 0.0, "content": "/static/notebook_files/support/384afd8246b51c2c.pdf", "analytics": "{'Study guide SAM': {'0': {'Cosine Similarity': 0.4, 'Word Mover': 1000, 'Text Distance': 0.040446304044630454, 'Jaccard Similarity': 0.08585858585858586}, '1': {'Cosine Similarity': 0.49, 'Word Mover': 1000, 'Text Distance': 0.06329113924050633, 'Jaccard Similarity': 0.136986301369863}, '2': {'Cosine Similarity': 0.58, 'Word Mover': 1000, 'Text Distance': 0.06721105527638194, 'Jaccard Similarity': 0.15848214285714285}, '3': {'Cosine Similarity': 0.56, 'Word Mover': 1000, 'Text Distance': 0.05299860529986056, 'Jaccard Similarity': 0.15013404825737264}, '4': {'Cosine Similarity': 0.6, 'Word Mover': 1000, 'Text Distance': 0.03417015341701535, 'Jaccard Similarity': 0.10985915492957747}, '5': {'Cosine Similarity': 0.66, 'Word Mover': 1000, 'Text Distance': 0.04253835425383545, 'Jaccard Similarity': 0.1278409090909091}, '6': {'Cosine Similarity': 0.66, 'Word Mover': 1000, 'Text Distance': 0.0704323570432357, 'Jaccard Similarity': 0.15274463007159905}, '7': {'Cosine Similarity': 0.6, 'Word Mover': 1000, 'Text Distance': 0.040446304044630454, 'Jaccard Similarity': 0.1366120218579235}, '8': {'Cosine Similarity': 0.57, 'Word Mover': 1000, 'Text Distance': 0.05788005578800559, 'Jaccard Similarity': 0.12048192771084337}, '9': {'Cosine Similarity': 0.07, 'Word Mover': 1000, 'Text Distance': 0.017433751743375137, 'Jaccard Similarity': 0.02368421052631579}, '10': {'Cosine Similarity': 0.08, 'Word Mover': 1000, 'Text Distance': 0.032775453277545274, 'Jaccard Similarity': 0.030456852791878174}, '11': {'Cosine Similarity': 0.23, 'Word Mover': 1000, 'Text Distance': 0.015341701534170138, 'Jaccard Similarity': 0.0440251572327044}}}", "is_pdf": true, "pdf_url": "NONE"}}}